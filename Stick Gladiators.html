<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Stick Gladiators: Super Evolve Tournament</title>
  <style>
    /* Animated gradient background for extra cool vibes */
    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(-45deg, #111, #333, #111, #555);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    /* Enhanced info panel styling with neon glow and shadow */
    #infoPanel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #0ff;
      padding: 15px;
      border-radius: 6px;
      max-width: 1000px;
      font-size: 15px;
      box-shadow: 0 0 10px #0ff;
    }
    #infoPanel h3 {
      margin: 0 0 10px 0;
      text-shadow: 0 0 5px #0ff;
    }
    #infoPanel div {
      margin-bottom: 5px;
    }
    #chromosomes p {
      margin: 5px 0;
      font-family: monospace;
      font-size: 13px;
    }
    #sliderContainer, #superEvolveContainer {
      margin-top: 10px;
    }
    #sliderContainer label, #superEvolveContainer label {
      margin-right: 10px;
    }
    /* Champion banner that appears when a fighter wins */
    #championBanner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 20px 30px;
      border-radius: 8px;
      font-size: 24px;
      font-weight: bold;
      color: #f44;
      text-align: center;
      box-shadow: 0 0 20px #f44;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    /* Super Evolve button styling */
    #superEvolveBtn {
      padding: 6px 12px;
      font-size: 14px;
      background-color: #222;
      color: #0ff;
      border: 1px solid #0ff;
      border-radius: 4px;
      cursor: pointer;
    }
    #superEvolveBtn:hover {
      background-color: #333;
    }
  </style>
</head>
<body>
  <canvas id="matterCanvas"></canvas>
  <div id="infoPanel">
    <h3>Generation: <span id="generation">1</span></h3>
    <div id="redStats">Red: 100</div>
    <div id="blueStats">Blue: 100</div>
    <div id="chromosomes">
      <p><strong>Red Chromosome:</strong><br><span id="redGene"></span></p>
      <p><strong>Blue Chromosome:</strong><br><span id="blueGene"></span></p>
    </div>
    <div id="sliderContainer">
      <label for="timeSlider">Time Scale:</label>
      <input type="range" id="timeSlider" min="0.1" max="2" step="0.1" value="1">
      <span id="timeDisplay">1.0</span>
    </div>
    <div id="superEvolveContainer">
      <label for="superEvolveBtn">Super Evolve:</label>
      <button id="superEvolveBtn">Activate</button>
    </div>
  </div>
  
  <!-- Champion Banner -->
  <div id="championBanner"></div>

  <!-- Matter.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // Short, sassy, and slightly nerdy: the perfect code doc style.

    // --- Matter.js Aliases ---
    const { Engine, Render, World, Bodies, Body, Composite, Constraint, Events } = Matter;

    // --- Basic Setup ---
    const engine = Engine.create();
    const world = engine.world;
    const canvas = document.getElementById('matterCanvas');
    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: 800,
        height: 500,
        background: 'transparent',
        wireframes: false
      }
    });
    Render.run(render);
    Engine.run(engine);

    // --- Time Scale Controls ---
    const timeSlider = document.getElementById('timeSlider');
    const timeDisplay = document.getElementById('timeDisplay');
    timeSlider.addEventListener('input', (e) => {
      const timeScaleValue = parseFloat(e.target.value);
      engine.timing.timeScale = timeScaleValue;
      timeDisplay.textContent = timeScaleValue.toFixed(1);
    });

    // --- Arena Walls ---
    const wallOptions = { isStatic: true, render: { fillStyle: '#555' } };
    const ground = Bodies.rectangle(400, 490, 800, 20, wallOptions);
    const ceiling = Bodies.rectangle(400, 10, 800, 20, wallOptions);
    const leftWall = Bodies.rectangle(10, 250, 20, 500, wallOptions);
    const rightWall = Bodies.rectangle(790, 250, 20, 500, wallOptions);
    World.add(world, [ground, ceiling, leftWall, rightWall]);

    // --- Global Tournament Vars ---
    let generation = 1;
    let redFighter, blueFighter;
    let tournamentOver = false;

    // --- Sound Effects ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function playImpactSound(volume = 0.5, frequency = 200) {
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }

    // --- Champion Banner ---
    const championBanner = document.getElementById('championBanner');
    function showChampionBanner(championTeam) {
      championBanner.textContent = `Champion: ${championTeam.toUpperCase()} wins!`;
      championBanner.style.opacity = 1;
      setTimeout(() => {
        championBanner.style.opacity = 0;
      }, 1500);
    }

    // --- Chromosome & Mutations ---
    function createChromosome(team) {
      // We'll tweak each stat range for red vs. blue to emphasize differences
      let punchMin, punchMax, cooldownMin, cooldownMax;
      let torsoWidthMin, torsoWidthMax;
      let torsoHeightMin, torsoHeightMax;
      let armLenMin, armLenMax;
      let armThickMin, armThickMax;
      let legLenMin, legLenMax;
      let legThickMin, legThickMax;

      if (team === 'red') {
        // Red: more power, shorter cooldown, bigger arms, etc.
        punchMin = 0.8;   punchMax = 1.6;
        cooldownMin = 20; cooldownMax = 40;
        torsoWidthMin = 30;  torsoWidthMax = 60;
        torsoHeightMin = 60; torsoHeightMax = 100;
        armLenMin = 40;   armLenMax = 80;
        armThickMin = 8;  armThickMax = 14;
        legLenMin = 50;   legLenMax = 90;
        legThickMin = 12; legThickMax = 18;
      } else {
        // Blue: maybe a bit more cooldown, more variable torso, etc.
        punchMin = 0.3;   punchMax = 1.2;
        cooldownMin = 30; cooldownMax = 60;
        torsoWidthMin = 35;  torsoWidthMax = 70;
        torsoHeightMin = 50; torsoHeightMax = 90;
        armLenMin = 35;   armLenMax = 85;
        armThickMin = 6;  armThickMax = 10;
        legLenMin = 50;   legLenMax = 80;
        legThickMin = 10; legThickMax = 16;
      }

      // Randomize each stat from the chosen range
      const punchForce = (Math.random() * (punchMax - punchMin) + punchMin).toFixed(2);
      const cooldown = Math.floor(Math.random() * (cooldownMax - cooldownMin) + cooldownMin);
      const torsoWidth = Math.floor(Math.random() * (torsoWidthMax - torsoWidthMin) + torsoWidthMin);
      const torsoHeight = Math.floor(Math.random() * (torsoHeightMax - torsoHeightMin) + torsoHeightMin);
      const armLength = Math.floor(Math.random() * (armLenMax - armLenMin) + armLenMin);
      const armThickness = Math.floor(Math.random() * (armThickMax - armThickMin) + armThickMin);
      const legLength = Math.floor(Math.random() * (legLenMax - legLenMin) + legLenMin);
      const legThickness = Math.floor(Math.random() * (legThickMax - legThickMin) + legThickMin);

      return {
        punchForce,
        cooldown,
        torsoWidth,
        torsoHeight,
        armLength,
        armThickness,
        legLength,
        legThickness
      };
    }

    function mutateGenome(genome) {
      // up to Â±30% random shift
      function mutateValue(value) {
        const factor = 1 + (Math.random() * 0.6 - 0.3);
        return Math.max(1, Math.round(value * factor));
      }
      let newPunchForce = (
        parseFloat(genome.punchForce) *
        (1 + (Math.random() * 0.6 - 0.3))
      ).toFixed(2);
      let newCooldown = Math.max(
        1,
        Math.floor(genome.cooldown * (1 + (Math.random() * 0.6 - 0.3)))
      );
      return {
        punchForce: newPunchForce,
        cooldown: newCooldown,
        torsoWidth: mutateValue(genome.torsoWidth),
        torsoHeight: mutateValue(genome.torsoHeight),
        armLength: mutateValue(genome.armLength),
        armThickness: mutateValue(genome.armThickness),
        legLength: mutateValue(genome.legLength),
        legThickness: mutateValue(genome.legThickness)
      };
    }

    function superMutateGenome(genome) {
      // up to +50% or -30%
      function superMutateValue(value) {
        const factor = 1 + (Math.random() * 0.8 - 0.3);
        return Math.max(1, Math.round(value * factor));
      }
      let newPunchForce = (
        parseFloat(genome.punchForce) *
        (1 + (Math.random() * 0.8 - 0.3))
      ).toFixed(2);
      let newCooldown = Math.max(
        1,
        Math.floor(genome.cooldown * (1 + (Math.random() * 0.8 - 0.3)))
      );
      return {
        punchForce: newPunchForce,
        cooldown: newCooldown,
        torsoWidth: superMutateValue(genome.torsoWidth),
        torsoHeight: superMutateValue(genome.torsoHeight),
        armLength: superMutateValue(genome.armLength),
        armThickness: superMutateValue(genome.armThickness),
        legLength: superMutateValue(genome.legLength),
        legThickness: superMutateValue(genome.legThickness)
      };
    }

    /**
     * createGladiator: builds a 12-piece fighter with pill-shaped limbs & torso.
     */
    function createGladiator(x, color, team, chromosome) {
      const { torsoWidth, torsoHeight, armLength, armThickness, legLength, legThickness } = chromosome;

      // We'll define a "chamfer" object for each rectangle to give them round edges
      // effectively making them "pills."
      // For torso, let's pick a chamfer radius that looks decent. We'll do about 1/4 the smaller dimension.
      const torsoChamfer = { radius: Math.min(torsoWidth, torsoHeight) * 0.25 };

      // Head is still a circle
      const torso = Bodies.rectangle(x, 300, torsoWidth, torsoHeight, {
        chamfer: torsoChamfer,
        render: { fillStyle: color }
      });
      const head = Bodies.circle(x, 300 - (torsoHeight / 2 + 20), 20, {
        render: { fillStyle: color }
      });

      // Offsets for limb attachment
      const shoulderOffsetY = torsoHeight / 4;
      const hipOffsetY = torsoHeight / 2;

      // We'll define arms & legs as capsules with chamfer = half thickness
      const upperArmLen = armLength * 0.5;
      const forearmLen = armLength * 0.5;
      const armChamfer = { radius: armThickness / 2 };

      // Left Upper Arm
      const leftUpperArm = Bodies.rectangle(
        x - torsoWidth / 2 - upperArmLen / 2,
        300 - shoulderOffsetY,
        upperArmLen,
        armThickness,
        {
          chamfer: armChamfer,
          render: { fillStyle: color }
        }
      );
      // Left Forearm
      const leftForearm = Bodies.rectangle(
        leftUpperArm.position.x - forearmLen,
        leftUpperArm.position.y,
        forearmLen,
        armThickness,
        {
          chamfer: armChamfer,
          render: { fillStyle: color }
        }
      );

      // Right Upper Arm
      const rightUpperArm = Bodies.rectangle(
        x + torsoWidth / 2 + upperArmLen / 2,
        300 - shoulderOffsetY,
        upperArmLen,
        armThickness,
        {
          chamfer: armChamfer,
          render: { fillStyle: color }
        }
      );
      // Right Forearm
      const rightForearm = Bodies.rectangle(
        rightUpperArm.position.x + forearmLen,
        rightUpperArm.position.y,
        forearmLen,
        armThickness,
        {
          chamfer: armChamfer,
          render: { fillStyle: color }
        }
      );

      // Legs
      const thighLen = legLength * 0.5;
      const calfLen = legLength * 0.5;
      const footHeight = 20;
      const legChamfer = { radius: legThickness / 2 };
      const footChamfer = { radius: footHeight / 2 };

      // Left Thigh
      const leftThigh = Bodies.rectangle(
        x - torsoWidth / 4,
        300 + hipOffsetY + thighLen / 2,
        legThickness,
        thighLen,
        {
          chamfer: legChamfer,
          render: { fillStyle: color }
        }
      );
      // Left Calf
      const leftCalf = Bodies.rectangle(
        leftThigh.position.x,
        leftThigh.position.y + thighLen / 2 + calfLen / 2,
        legThickness,
        calfLen,
        {
          chamfer: legChamfer,
          render: { fillStyle: color }
        }
      );
      // Left Foot
      const leftFoot = Bodies.rectangle(
        leftCalf.position.x,
        leftCalf.position.y + calfLen / 2 + footHeight / 2,
        legThickness * 1.3,
        footHeight,
        {
          chamfer: footChamfer,
          render: { fillStyle: color }
        }
      );

      // Right Thigh
      const rightThigh = Bodies.rectangle(
        x + torsoWidth / 4,
        300 + hipOffsetY + thighLen / 2,
        legThickness,
        thighLen,
        {
          chamfer: legChamfer,
          render: { fillStyle: color }
        }
      );
      // Right Calf
      const rightCalf = Bodies.rectangle(
        rightThigh.position.x,
        rightThigh.position.y + thighLen / 2 + calfLen / 2,
        legThickness,
        calfLen,
        {
          chamfer: legChamfer,
          render: { fillStyle: color }
        }
      );
      // Right Foot
      const rightFoot = Bodies.rectangle(
        rightCalf.position.x,
        rightCalf.position.y + calfLen / 2 + footHeight / 2,
        legThickness * 1.3,
        footHeight,
        {
          chamfer: footChamfer,
          render: { fillStyle: color }
        }
      );

      // --- Constraints (Joints) ---
      const constraints = [
        // Head <-> Torso
        Constraint.create({
          bodyA: head,
          pointA: { x: 0, y: 20 },
          bodyB: torso,
          pointB: { x: 0, y: -torsoHeight / 2 },
          stiffness: 1,
          length: 0
        }),
        // Torso <-> Left Upper Arm
        Constraint.create({
          bodyA: torso,
          pointA: { x: -torsoWidth / 2, y: -shoulderOffsetY },
          bodyB: leftUpperArm,
          pointB: { x: upperArmLen / 2, y: 0 },
          stiffness: 1,
          length: 0
        }),
        // Left Upper Arm <-> Left Forearm
        Constraint.create({
          bodyA: leftUpperArm,
          pointA: { x: -upperArmLen / 2, y: 0 },
          bodyB: leftForearm,
          pointB: { x: forearmLen / 2, y: 0 },
          stiffness: 1,
          length: 0
        }),
        // Torso <-> Right Upper Arm
        Constraint.create({
          bodyA: torso,
          pointA: { x: torsoWidth / 2, y: -shoulderOffsetY },
          bodyB: rightUpperArm,
          pointB: { x: -upperArmLen / 2, y: 0 },
          stiffness: 1,
          length: 0
        }),
        // Right Upper Arm <-> Right Forearm
        Constraint.create({
          bodyA: rightUpperArm,
          pointA: { x: upperArmLen / 2, y: 0 },
          bodyB: rightForearm,
          pointB: { x: -forearmLen / 2, y: 0 },
          stiffness: 1,
          length: 0
        }),
        // Torso <-> Left Thigh
        Constraint.create({
          bodyA: torso,
          pointA: { x: -torsoWidth / 4, y: hipOffsetY },
          bodyB: leftThigh,
          pointB: { x: 0, y: -thighLen / 2 },
          stiffness: 1,
          length: 0
        }),
        // Left Thigh <-> Left Calf
        Constraint.create({
          bodyA: leftThigh,
          pointA: { x: 0, y: thighLen / 2 },
          bodyB: leftCalf,
          pointB: { x: 0, y: -calfLen / 2 },
          stiffness: 1,
          length: 0
        }),
        // Left Calf <-> Left Foot
        Constraint.create({
          bodyA: leftCalf,
          pointA: { x: 0, y: calfLen / 2 },
          bodyB: leftFoot,
          pointB: { x: 0, y: -footHeight / 2 },
          stiffness: 1,
          length: 0
        }),
        // Torso <-> Right Thigh
        Constraint.create({
          bodyA: torso,
          pointA: { x: torsoWidth / 4, y: hipOffsetY },
          bodyB: rightThigh,
          pointB: { x: 0, y: -thighLen / 2 },
          stiffness: 1,
          length: 0
        }),
        // Right Thigh <-> Right Calf
        Constraint.create({
          bodyA: rightThigh,
          pointA: { x: 0, y: thighLen / 2 },
          bodyB: rightCalf,
          pointB: { x: 0, y: -calfLen / 2 },
          stiffness: 1,
          length: 0
        }),
        // Right Calf <-> Right Foot
        Constraint.create({
          bodyA: rightCalf,
          pointA: { x: 0, y: calfLen / 2 },
          bodyB: rightFoot,
          pointB: { x: 0, y: -footHeight / 2 },
          stiffness: 1,
          length: 0
        })
      ];

      // --- Bundle all parts into a Composite ---
      const fighterParts = [
        torso, head,
        leftUpperArm, leftForearm, rightUpperArm, rightForearm,
        leftThigh, leftCalf, leftFoot,
        rightThigh, rightCalf, rightFoot
      ];
      const fighter = Composite.create({ label: team });
      Composite.add(fighter, [...fighterParts, ...constraints]);

      // Attach references for collision/damage logic
      fighterParts.forEach(body => body.fighter = fighter);
      fighter.torso = torso;
      fighter.leftPunchArm = leftForearm;
      fighter.rightPunchArm = rightForearm;
      fighter.leftKickLeg = leftCalf;
      fighter.rightKickLeg = rightCalf;
      fighter.health = 100;
      fighter.team = team;
      fighter.chromosome = chromosome;
      fighter.cooldownCounter = 0;

      return fighter;
    }

    // --- Restart & Evolve ---
    function restartTournament(championGenome, mutationFunction = mutateGenome) {
      Composite.remove(world, redFighter);
      Composite.remove(world, blueFighter);

      const newGenome = mutationFunction(championGenome);
      redFighter = createGladiator(200, '#f44', 'red', newGenome);
      blueFighter = createGladiator(600, '#44f', 'blue', newGenome);
      World.add(world, [redFighter, blueFighter]);

      generation++;
      document.getElementById('generation').textContent = generation;
      document.getElementById('redGene').textContent = JSON.stringify(newGenome);
      document.getElementById('blueGene').textContent = JSON.stringify(newGenome);

      playImpactSound(0.5, 300);
      tournamentOver = false;
    }

    // --- Initialize Fighters ---
    let redChromosome = createChromosome('red');
    let blueChromosome = createChromosome('blue');
    redFighter = createGladiator(200, '#f44', 'red', redChromosome);
    blueFighter = createGladiator(600, '#44f', 'blue', blueChromosome);
    World.add(world, [redFighter, blueFighter]);

    document.getElementById('redGene').textContent = JSON.stringify(redChromosome);
    document.getElementById('blueGene').textContent = JSON.stringify(blueChromosome);
    document.getElementById('generation').textContent = generation;

    // --- Attack Logic (Before Update) ---
    Events.on(engine, 'beforeUpdate', () => {
      [redFighter, blueFighter].forEach(fighter => {
        fighter.cooldownCounter--;
        if (fighter.cooldownCounter <= 0) {
          const direction = fighter.team === 'red' ? 1 : -1;
          const force = parseFloat(fighter.chromosome.punchForce);
          Body.setAngularVelocity(fighter.leftPunchArm, direction * force);
          Body.setAngularVelocity(fighter.rightPunchArm, direction * force);
          Body.setAngularVelocity(fighter.leftKickLeg, direction * force);
          Body.setAngularVelocity(fighter.rightKickLeg, direction * force);
          fighter.cooldownCounter = fighter.chromosome.cooldown;
        }
      });
    });

    // --- After Update (Check health, scoreboard, etc.) ---
    Events.on(engine, 'afterUpdate', () => {
      document.getElementById('redStats').textContent = `Red: ${Math.max(0, redFighter.health.toFixed(0))}`;
      document.getElementById('blueStats').textContent = `Blue: ${Math.max(0, blueFighter.health.toFixed(0))}`;

      if (!tournamentOver) {
        if (redFighter.health < 0) {
          tournamentOver = true;
          console.log(`Champion of Generation ${generation}: BLUE wins!`);
          showChampionBanner('blue');
          setTimeout(() => {
            restartTournament(blueFighter.chromosome);
          }, 1000);
        } else if (blueFighter.health < 0) {
          tournamentOver = true;
          console.log(`Champion of Generation ${generation}: RED wins!`);
          showChampionBanner('red');
          setTimeout(() => {
            restartTournament(redFighter.chromosome);
          }, 1000);
        }
      }
    });

    // --- Collision & Damage ---
    Events.on(engine, 'collisionStart', event => {
      event.pairs.forEach(pair => {
        const { bodyA, bodyB } = pair;
        if (!bodyA.fighter || !bodyB.fighter) return;
        if (bodyA.fighter === bodyB.fighter) return;

        function isAttackLimb(body) {
          const f = body.fighter;
          return (
            body === f.leftPunchArm ||
            body === f.rightPunchArm ||
            body === f.leftKickLeg ||
            body === f.rightKickLeg
          );
        }
        
        if (isAttackLimb(bodyA) || isAttackLimb(bodyB)) {
          const vx = bodyA.velocity.x - bodyB.velocity.x;
          const vy = bodyA.velocity.y - bodyB.velocity.y;
          const impactSpeed = Math.sqrt(vx * vx + vy * vy);
          const damage = Math.max(5, Math.floor(impactSpeed * 10));
          
          if (damage > 10) playImpactSound(0.4, 250);

          if (isAttackLimb(bodyA)) {
            bodyB.fighter.health -= damage;
          }
          if (isAttackLimb(bodyB)) {
            bodyA.fighter.health -= damage;
          }
        }
      });
    });

    // --- Super Evolve Button ---
    document.getElementById('superEvolveBtn').addEventListener('click', () => {
      let champion;
      if (redFighter.health < 0) {
        champion = blueFighter;
      } else if (blueFighter.health < 0) {
        champion = redFighter;
      } else {
        champion = redFighter.health >= blueFighter.health ? redFighter : blueFighter;
      }
      console.log(`Super Evolving champion from team ${champion.team}!`);
      restartTournament(champion.chromosome, superMutateGenome);
    });
  </script>
</body>
</html>
