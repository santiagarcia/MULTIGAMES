<!--
  Title: Overlapped 3D — Interfering Dots (No Rods)
  Author: Santiago Garcia and contributors
  License: MIT
  Usage: Left-drag to pull the nearest point with a spring. Right-click to pin/unpin. Space toggles pause.
         Sidebar sliders control time scale, damping, mouse spring, point size, per-cloud stiffness, and cross-cloud coupling.
         Toggle Grid/Axes. window.api exposes: setCoupling(k,r), setStiffness(k1,k2,k3,k4), pulse(), randomImpulse(seed), pause(bool), reset(), seedRandom(seed).
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Overlapped 3D — Interfering Dots (No Rods)</title>
  <meta name="description" content="Four overlapping 3D point clouds with Laplacian cohesion and Gaussian cross-cloud coupling. CPU sim, zero-GC hot loop.">
  <style>
    :root{
      --bg:#0b0b0c; --panel:#141418; --ink:#eaeaea; --muted:#9aa0a6; --accent:#64d2ff; --stroke:#2a2a2f;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
         display:grid; grid-template-rows:auto 1fr; gap:8px; padding:8px}
    header, .panel{background:var(--panel); border:1px solid var(--stroke); border-radius:16px; padding:10px 12px}
    header h1{margin:0; font-size:clamp(18px,3.5vw,26px)}
    header p{margin:6px 0 0 0; color:var(--muted)}
    .wrap{display:grid; grid-template-columns: 340px 1fr; gap:8px; min-height:0}
    #stage{position:relative; border:1px solid var(--stroke); border-radius:16px; overflow:hidden; min-height:70vh}
    canvas{display:block; width:100%; height:100%}
    .panel{display:flex; flex-direction:column; gap:12px; overflow:auto}
    .group{border-top:1px solid var(--stroke); padding-top:10px}
    .group:first-child{border-top:none; padding-top:0}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button{appearance:none; border:1px solid var(--stroke); background:#1a1a20; color:var(--ink); padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:600; font-size:13px}
    button:hover{border-color:#3a3a45}
    button.primary{background:var(--accent); color:#0b0b0c; border-color:transparent}
    label{display:flex; justify-content:space-between; align-items:center; gap:8px; font-size:13px; color:var(--muted)}
    input[type="range"]{width:100%}
    .slider-row{display:grid; grid-template-columns:1fr 76px; gap:10px; align-items:center}
    .value{font-variant-numeric:tabular-nums; text-align:right; width:76px; color:var(--ink)}
    .key{display:flex; gap:8px; flex-wrap:wrap; font-size:12px; color:var(--muted)}
    .swatch{width:10px; height:10px; border-radius:2px; display:inline-block}
    .hud{position:absolute; right:8px; top:8px; background:rgba(0,0,0,.45); border:1px solid var(--stroke); color:#eaeaea; padding:6px 8px; border-radius:10px; font-size:12px; pointer-events:none; font-variant-numeric:tabular-nums}
  </style>
</head>
<body>
  <header>
    <h1>Overlapped 3D — <span style="color:#9ad9ff">Interfering Dots</span> <span style="font-size:12px; color:#9aa0a6">(No Rods)</span></h1>
    <p>Four overlapped point clouds with Laplacian cohesion and Gaussian cross-cloud coupling. Left-drag: spring grab. Right-click: pin/unpin. Space: pause.</p>
  </header>

  <div class="wrap">
    <aside class="panel">
      <div class="group">
        <div class="row">
          <button id="btnPause" class="primary" title="Pause/Play (Space)">Pause</button>
          <button id="btnReset" title="Reset simulation to rest state">Reset</button>
          <button id="btnPulse" title="Radial outward velocity pulse">Pulse</button>
          <button id="btnRand" title="Seeded random velocity impulse">Random Impulse</button>
        </div>
        <div class="key" aria-label="Legend">
          <span><span class="swatch" style="background:#00ff99"></span> Cloud A (12×12 @ 1.1)</span>
          <span><span class="swatch" style="background:#ff66cc"></span> Cloud B (16×14 @ 1.0)</span>
          <span><span class="swatch" style="background:#ffd166"></span> Cloud C (20×16 @ 0.9)</span>
          <span><span class="swatch" style="background:#7cff7c"></span> Cloud D (26×20 @ 0.8)</span>
        </div>
      </div>

      <div class="group">
        <h3 style="margin:0 0 6px 0;font-size:14px;color:#eaeaea">Physics</h3>
        <div class="slider-row"><label title="Time scale multiplier">Time scale <span class="value" id="valTime">1.00×</span></label><input id="rngTime" type="range" min="0.25" max="2.0" value="1.0" step="0.01"/></div>
        <div class="slider-row"><label title="Velocity damping 0..0.08">Damping <span class="value" id="valDamp">0.020</span></label><input id="rngDamp" type="range" min="0" max="0.08" value="0.02" step="0.001"/></div>
        <div class="slider-row"><label title="Mouse spring stiffness">Mouse-k <span class="value" id="valMouseK">260</span></label><input id="rngMouseK" type="range" min="50" max="1000" value="260" step="1"/></div>
        <div class="slider-row"><label title="Point size in world units">Point size <span class="value" id="valPSize">0.10</span></label><input id="rngPSize" type="range" min="0.02" max="0.40" value="0.10" step="0.01"/></div>
      </div>

      <div class="group">
        <h3 style="margin:0 0 6px 0;font-size:14px;color:#eaeaea">Stiffness</h3>
        <div class="slider-row"><label title="Internal cohesion for cloud A">k₁ (A) <span class="value" id="valK1">120</span></label><input id="rngK1" type="range" min="10" max="800" value="120" step="1"/></div>
        <div class="slider-row"><label title="Internal cohesion for cloud B">k₂ (B) <span class="value" id="valK2">160</span></label><input id="rngK2" type="range" min="10" max="800" value="160" step="1"/></div>
        <div class="slider-row"><label title="Internal cohesion for cloud C">k₃ (C) <span class="value" id="valK3">220</span></label><input id="rngK3" type="range" min="10" max="800" value="220" step="1"/></div>
        <div class="slider-row"><label title="Internal cohesion for cloud D">k₄ (D) <span class="value" id="valK4">280</span></label><input id="rngK4" type="range" min="10" max="800" value="280" step="1"/></div>
      </div>

      <div class="group">
        <h3 style="margin:0 0 6px 0;font-size:14px;color:#eaeaea">Coupling</h3>
        <div class="slider-row"><label title="Cross-cloud Gaussian strength">k_cpl <span class="value" id="valKc">180</span></label><input id="rngKc" type="range" min="10" max="800" value="180" step="1"/></div>
        <div class="slider-row"><label title="Coupling radius">r <span class="value" id="valR">2.00</span></label><input id="rngR" type="range" min="0.4" max="4.0" value="2.0" step="0.01"/></div>
        <div class="row">
          <label class="inline" style="gap:6px"><input id="chkGrid" type="checkbox" checked title="Toggle grid helper"> Show grid</label>
          <label class="inline" style="gap:6px"><input id="chkAxes" type="checkbox" checked title="Toggle axes helper"> Show axes</label>
        </div>
      </div>

      <div class="group">
        <small>Deterministic hooks on <code>window.api</code>. Hold right-click on a point to toggle pin. Colors: A #00ff99, B #ff66cc, C #ffd166, D #7cff7c.</small>
      </div>
    </aside>

    <section id="stage">
      <div class="hud" id="hud">ms: sim 0.00 | rend 0.00 | pairs 0 | cell 0.00 | N 0</div>
    </section>
  </div>

  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  ;(function(){
    'use strict';

    // ======================== Math & RNG helpers ========================
    /** Clamp a value to [a,b]. */
    function clamp(x,a,b){ return x<a?a:(x>b?b:x); }
    /** Linear congruential generator for deterministic randomness. */
    var rngState = 123456789>>>0;
    function seedRandom(seed){ rngState = (seed>>>0) || 1; }
    function rand(){ rngState = (1664525*rngState + 1013904223)>>>0; return rngState/4294967296; }

    // ======================== Scene & UI setup ========================
    var stage = document.getElementById('stage');
    var hud = document.getElementById('hud');
    var renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(stage.clientWidth, stage.clientHeight);
    renderer.setClearColor(0x0a0a0e, 1);
    stage.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(55, stage.clientWidth/stage.clientHeight, 0.1, 2000);
    camera.position.set(18, 12, 22);
  // Orbit controls (fallback to no-op if library fails to load)
  var controls = (THREE.OrbitControls) ? new THREE.OrbitControls(camera, renderer.domElement) : { enableDamping:false, update:function(){}, target:{ set:function(){}} };
  // Focus the origin so the overlapped clouds are in view on the first frame
  if(typeof THREE.OrbitControls === 'function') { controls.enableDamping = true; controls.dampingFactor = 0.08; controls.target.set(0,0,0); controls.update(); }
  else { camera.lookAt(0,0,0); }

    var gridHelper = new THREE.GridHelper(100, 100, 0x222222, 0x222222); gridHelper.material.opacity=0.35; gridHelper.material.transparent=true; scene.add(gridHelper);
    var axesHelper = new THREE.AxesHelper(3); scene.add(axesHelper);

    // UI elements
    var btnPause = document.getElementById('btnPause');
    var btnReset = document.getElementById('btnReset');
    var btnPulse = document.getElementById('btnPulse');
    var btnRand = document.getElementById('btnRand');
    var rngTime = document.getElementById('rngTime');
    var rngDamp = document.getElementById('rngDamp');
    var rngMouseK = document.getElementById('rngMouseK');
    var rngPSize = document.getElementById('rngPSize');
    var rngK1 = document.getElementById('rngK1');
    var rngK2 = document.getElementById('rngK2');
    var rngK3 = document.getElementById('rngK3');
    var rngK4 = document.getElementById('rngK4');
    var rngKc = document.getElementById('rngKc');
    var rngR = document.getElementById('rngR');
    var chkGrid = document.getElementById('chkGrid');
    var chkAxes = document.getElementById('chkAxes');

    var valTime = document.getElementById('valTime');
    var valDamp = document.getElementById('valDamp');
    var valMouseK = document.getElementById('valMouseK');
    var valPSize = document.getElementById('valPSize');
    var valK1 = document.getElementById('valK1');
    var valK2 = document.getElementById('valK2');
    var valK3 = document.getElementById('valK3');
    var valK4 = document.getElementById('valK4');
    var valKc = document.getElementById('valKc');
    var valR = document.getElementById('valR');

    function syncLabels(){
      valTime.textContent = (+rngTime.value).toFixed(2)+'×';
      valDamp.textContent = (+rngDamp.value).toFixed(3);
      valMouseK.textContent = (+rngMouseK.value).toFixed(0);
      valPSize.textContent = (+rngPSize.value).toFixed(2);
      valK1.textContent = (+rngK1.value).toFixed(0);
      valK2.textContent = (+rngK2.value).toFixed(0);
      valK3.textContent = (+rngK3.value).toFixed(0);
      valK4.textContent = (+rngK4.value).toFixed(0);
      valKc.textContent = (+rngKc.value).toFixed(0);
      valR.textContent = (+rngR.value).toFixed(2);
    }
    syncLabels();

    // ======================== Simulation parameters ========================
    // Cloud definitions: columns, rows, spacing, color
    var clouds = [
      { name:'A', cols:12, rows:12, spacing:1.1, color:0x00ff99 },
      { name:'B', cols:16, rows:14, spacing:1.0, color:0xff66cc },
      { name:'C', cols:20, rows:16, spacing:0.9, color:0xffd166 },
      { name:'D', cols:26, rows:20, spacing:0.8, color:0x7cff7c }
    ];
    var numClouds = clouds.length;
    var N = 0; // total particles
    var cOffsets = new Int32Array(numClouds+1); // [0..numClouds] cumulative
    var cloudId; // Int8 per particle: 0..3

    // Per-particle SoA arrays
    var px, py, pz, vx, vy, vz, fx, fy, fz, pins, restX, restY, restZ;
    // 4-neighbor indices (-1 sentinel). Length N each.
    var nL, nR, nU, nD;

    // Spatial hash (intrusive linked lists)
    var cellSize = 2.0 * 0.9; // initial max(0.8, 0.9*r)
    var rCouple = 2.0, r2 = rCouple*rCouple;
    var kCouple = 180.0;
    var BUCKETS = 8192; // power of two for masking
    var head, next, cellX, cellY, cellZ;
    var neighborOffsets = new Int8Array(27*3); // 27 triplets

    // Rendering objects per cloud
    function CloudRender(start,count,color){
      this.start=start; this.count=count; this.color=color;
      var geom = new THREE.BufferGeometry();
      // Position buffer for this cloud only
      var positions = new Float32Array(count*3);
      var colors = new Float32Array(count*3);
      this.positions = positions; this.colors = colors;
      this.attrPos = new THREE.BufferAttribute(positions,3);
      this.attrPos.setUsage(THREE.DynamicDrawUsage);
      this.attrCol = new THREE.BufferAttribute(colors,3);
      this.attrCol.setUsage(THREE.DynamicDrawUsage);
      geom.setAttribute('position', this.attrPos);
      geom.setAttribute('color', this.attrCol);
      var mat = new THREE.PointsMaterial({ size: +rngPSize.value, vertexColors: true, sizeAttenuation: true });
      this.mat = mat; this.geom = geom;
      this.points = new THREE.Points(geom, mat);
    }
    var renders = [];

    // Per-cloud internal stiffness
    var k1=120, k2=160, k3=220, k4=280; // defaults
    var tetherK = 0.5; // mild tether to rest to prevent drift
    var damping = 0.02; // default, updated from UI
    var timeScale = 1.0;
    var mouseK = 260.0;

    // Picking & dragging state (reused temps to avoid allocs)
    var raycaster = new THREE.Raycaster();
    var mouseNDC = new THREE.Vector2();
    var grabbing = -1; // index or -1
    var plane = new THREE.Plane();
    var camDir = new THREE.Vector3();
    var ray = new THREE.Ray();
    var hit = new THREE.Vector3();
    var tmpV = new THREE.Vector3(); // reused scratch for UI pick distance calculation

    // Diagnostics
    var running = true;
    var lastTS = performance.now();
    var simMS = 0, rendMS = 0, ema = 0.12; // moving averages
    var pairCount = 0;

    // ======================== Initialization ========================
    function initArrays(){
      var i, c, cols, rows, spacing, start, count, end;
      // compute cumulative offsets
      cOffsets[0]=0;
      for(i=0;i<numClouds;i++){
        c = clouds[i];
        c.count = c.cols*c.rows;
        cOffsets[i+1] = cOffsets[i] + c.count;
      }
      N = cOffsets[numClouds];

      // allocate SoA
      px=new Float32Array(N); py=new Float32Array(N); pz=new Float32Array(N);
      vx=new Float32Array(N); vy=new Float32Array(N); vz=new Float32Array(N);
      fx=new Float32Array(N); fy=new Float32Array(N); fz=new Float32Array(N);
      pins=new Uint8Array(N);
      restX=new Float32Array(N); restY=new Float32Array(N); restZ=new Float32Array(N);
      nL=new Int32Array(N); nR=new Int32Array(N); nU=new Int32Array(N); nD=new Int32Array(N);
      cloudId=new Int8Array(N);

      // spatial hash arrays
      head=new Int32Array(BUCKETS);
      next=new Int32Array(N);
      cellX=new Int32Array(N); cellY=new Int32Array(N); cellZ=new Int32Array(N);

      // neighbor offsets (27)
      var idx=0, dx,dy,dz;
      for(dz=-1;dz<=1;dz++) for(dy=-1;dy<=1;dy++) for(dx=-1;dx<=1;dx++){
        neighborOffsets[idx++] = dx; neighborOffsets[idx++] = dy; neighborOffsets[idx++] = dz;
      }

      // place clouds around origin with small offsets for visibility
      var centers = [
        [ -2.0, 0.0, -1.6 ],
        [  2.0, 0.0, -1.0 ],
        [ -1.2, 0.0,  2.0 ],
        [  1.2, 0.0,  1.5 ]
      ];

      for(i=0;i<numClouds;i++){
        c = clouds[i]; cols=c.cols; rows=c.rows; spacing=c.spacing; start=cOffsets[i]; end=cOffsets[i+1]; count=end-start;
        var cx=centers[i][0], cy=centers[i][1], cz=centers[i][2];
        var ox = - (cols-1)*0.5*spacing;
        var oz = - (rows-1)*0.5*spacing;
        var j, idxP, ix, iz;
        for(iz=0; iz<rows; iz++){
          for(ix=0; ix<cols; ix++){
            idxP = start + iz*cols + ix;
            var x = cx + ox + ix*spacing;
            var y = cy;
            var z = cz + oz + iz*spacing;
            px[idxP]=restX[idxP]=x; py[idxP]=restY[idxP]=y; pz[idxP]=restZ[idxP]=z;
            vx[idxP]=vy[idxP]=vz[idxP]=0;
            pins[idxP]=0;
            cloudId[idxP]=i;
            // neighbors in this cloud (4-neighbor lattice)
            nL[idxP] = (ix>0)? (idxP-1) : -1;
            nR[idxP] = (ix+1<cols)? (idxP+1) : -1;
            nU[idxP] = (iz>0)? (idxP-cols) : -1;
            nD[idxP] = (iz+1<rows)? (idxP+cols) : -1;
          }
        }
      }

      // build render objects per cloud
      for(i=0;i<numClouds;i++){
        start=cOffsets[i]; end=cOffsets[i+1]; count=end-start; c=clouds[i];
        var cr = new CloudRender(start, count, c.color);
        // initialize colors to base cloud color; pinned will be white
        var col = new THREE.Color(c.color);
        var R=col.r, G=col.g, B=col.b; var k;
        for(k=0;k<count;k++){ var base=k*3; cr.colors[base]=R; cr.colors[base+1]=G; cr.colors[base+2]=B; }
        cr.attrCol.needsUpdate = true;
        renders.push(cr); scene.add(cr.points);
      }
      updatePointSize(+rngPSize.value);
    }

    function updatePointSize(size){
      for(var i=0;i<renders.length;i++) renders[i].mat.size = size;
    }

    // ======================== Spatial hash ========================
    /** Hash 3D integer cell coords to bucket index (power-of-two mask). */
    function hash(ix,iy,iz){
      // Large primes for mixing, ensure non-negative then mask
      var h = ((ix*73856093) ^ (iy*19349663) ^ (iz*83492791)) & (BUCKETS-1);
      return h;
    }
    /** Rebuild intrusive lists: head[]=-1; next[i]=head[h]; head[h]=i. */
    function rebuildHash(){
      // init heads to -1 (linear loop to avoid any hidden allocs)
      for(var b=0;b<BUCKETS;b++) head[b] = -1;
      var inv = 1.0 / cellSize; // slightly faster multiply than divide
      var i, ix,iy,iz, h;
      for(i=0;i<N;i++){
        ix = Math.floor(px[i]*inv);
        iy = Math.floor(py[i]*inv);
        iz = Math.floor(pz[i]*inv);
        cellX[i]=ix; cellY[i]=iy; cellZ[i]=iz;
        h = hash(ix,iy,iz);
        next[i] = head[h];
        head[h] = i;
      }
    }

    // ======================== Forces ========================
    /** Apply internal Laplacian cohesion per cloud and mild tether to rest. */
    function applyInternal(){
      var i, start, end, cols, rows, kint, nx,ny,nz, selfx,selfy,selfz, cnt;
      for(var c=0;c<numClouds;c++){
        start=cOffsets[c]; end=cOffsets[c+1];
        kint = (c===0? k1 : c===1? k2 : c===2? k3 : k4);
        for(i=start;i<end;i++){
          selfx=px[i]; selfy=py[i]; selfz=pz[i];
          nx=0; ny=0; nz=0; cnt=0;
          var j = nL[i]; if(j!==-1){ nx+=px[j]; ny+=py[j]; nz+=pz[j]; cnt++; }
          j = nR[i]; if(j!==-1){ nx+=px[j]; ny+=py[j]; nz+=pz[j]; cnt++; }
          j = nU[i]; if(j!==-1){ nx+=px[j]; ny+=py[j]; nz+=pz[j]; cnt++; }
          j = nD[i]; if(j!==-1){ nx+=px[j]; ny+=py[j]; nz+=pz[j]; cnt++; }
          if(cnt>0){ nx = nx/cnt - selfx; ny = ny/cnt - selfy; nz = nz/cnt - selfz; }
          // Laplacian force ~ k * (avg4 - self)
          fx[i] += kint * nx;
          fy[i] += kint * ny;
          fz[i] += kint * nz;
          // Tether to rest to keep sheets from drifting
          fx[i] += tetherK * (restX[i]-selfx);
          fy[i] += tetherK * (restY[i]-selfy);
          fz[i] += tetherK * (restZ[i]-selfz);
        }
      }
    }

    /** Apply Gaussian cross-cloud coupling using spatial hash. Equal-and-opposite forces. */
    function applyCoupling(){
      var i, j, h, b, off=0, dx,dy,dz, d2, w, f, ix,iy,iz, nix,niy,niz, idxOff;
      pairCount = 0;
      // For each particle i, traverse 27 neighbor buckets, visit indices j>i with different cloud
      for(i=0;i<N;i++){
        ix = cellX[i]; iy=cellY[i]; iz=cellZ[i];
        idxOff = 0;
        while(idxOff < 27*3){
          nix = ix + neighborOffsets[idxOff++];
          niy = iy + neighborOffsets[idxOff++];
          niz = iz + neighborOffsets[idxOff++];
          h = hash(nix,niy,niz);
          j = head[h];
          while(j!==-1){
            if(j>i && cloudId[j]!==cloudId[i]){
              dx = px[j]-px[i]; dy = py[j]-py[i]; dz = pz[j]-pz[i];
              d2 = dx*dx + dy*dy + dz*dz;
              if(d2 <= r2){
                // Gaussian weight exp(-d2/r2)
                w = Math.exp(-d2 / r2);
                f = kCouple * w;
                fx[i] += f*dx; fy[i] += f*dy; fz[i] += f*dz;
                fx[j] -= f*dx; fy[j] -= f*dy; fz[j] -= f*dz;
                pairCount++;
              }
            }
            j = next[j];
          }
        }
      }
    }

    /** Apply mouse spring to grabbed particle, projecting onto a plane through the particle facing the camera. */
    function applyMouseSpring(){
      if(grabbing<0) return;
      // Ray from mouse
      raycaster.setFromCamera(mouseNDC, camera);
      ray.copy(raycaster.ray);
      // Plane with normal towards camera passing through current particle position
      camDir.copy(camera.getWorldDirection(camDir)).multiplyScalar(-1);
      plane.setFromNormalAndCoplanarPoint(camDir, tmpV.set(px[grabbing], py[grabbing], pz[grabbing]));
      if(ray.intersectPlane(plane, hit)!==null){
        var k = mouseK;
        fx[grabbing] += k*(hit.x - px[grabbing]);
        fy[grabbing] += k*(hit.y - py[grabbing]);
        fz[grabbing] += k*(hit.z - pz[grabbing]);
      }
    }

    // ======================== Integration ========================
    /** Semi-implicit Euler integration with damping. Pins skip updates. */
    function integrate(dt){
      var i; var damp = 1.0 - damping;
      for(i=0;i<N;i++){
        if(pins[i]){ vx[i]=0; vy[i]=0; vz[i]=0; continue; }
        vx[i] = (vx[i] + fx[i]*dt) * damp;
        vy[i] = (vy[i] + fy[i]*dt) * damp;
        vz[i] = (vz[i] + fz[i]*dt) * damp;
        px[i] += vx[i]*dt;
        py[i] += vy[i]*dt;
        pz[i] += vz[i]*dt;
      }
    }

    // ======================== Rendering ========================
    function updateGeometries(){
      // Copy SoA -> interleaved float arrays per cloud
      for(var c=0;c<numClouds;c++){
        var r = renders[c];
        var start=r.start, end=start+r.count;
        var arr = r.positions; var k=0;
        for(var i=start;i<end;i++){
          arr[k++] = px[i]; arr[k++] = py[i]; arr[k++] = pz[i];
        }
        r.attrPos.needsUpdate = true;
      }
    }

    function setPinnedColor(index){
      var cid = cloudId[index]; var r = renders[cid]; var base = (index - r.start)*3;
      if(base<0 || base>=r.colors.length) return; // safety
      // Pinned = white, else base cloud color already set on reset; we'll also restore on unpin by recalculating
      r.colors[base]=1; r.colors[base+1]=1; r.colors[base+2]=1; r.attrCol.needsUpdate = true;
    }
    function clearPinnedColor(index){
      var cid = cloudId[index]; var r = renders[cid]; var base = (index - r.start)*3; if(base<0||base>=r.colors.length) return;
      var c = new THREE.Color(clouds[cid].color); r.colors[base]=c.r; r.colors[base+1]=c.g; r.colors[base+2]=c.b; r.attrCol.needsUpdate = true;
    }

    // ======================== Interaction events ========================
    function onMouseMove(e){
      var rect = renderer.domElement.getBoundingClientRect();
      mouseNDC.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
      mouseNDC.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
    }
    function pickNearestIndex(){
      // Raycaster already set from camera & mouse when needed
      raycaster.setFromCamera(mouseNDC, camera);
      var ro=raycaster.ray.origin, rd=raycaster.ray.direction;
      var best=-1, bestD2=1e9, i, wx,wy,wz, c1, pxr, pyr, pzr, dx,dy,dz, d2;
      for(i=0;i<N;i++){
        wx = px[i]-ro.x; wy = py[i]-ro.y; wz = pz[i]-ro.z;
        c1 = wx*rd.x + wy*rd.y + wz*rd.z; // projection length
        pxr = ro.x + rd.x*c1; pyr = ro.y + rd.y*c1; pzr = ro.z + rd.z*c1;
        dx = px[i]-pxr; dy = py[i]-pyr; dz = pz[i]-pzr; d2 = dx*dx+dy*dy+dz*dz;
        if(d2 < bestD2){ bestD2=d2; best=i; }
      }
      // Only allow grab if within threshold distance^2
      return (bestD2 <= 0.36)? best : -1;
    }
    function onMouseDown(e){
      if(e.button===0){
        grabbing = pickNearestIndex();
      }else if(e.button===2){
        var idx = pickNearestIndex(); if(idx>=0){ pins[idx] = pins[idx]^1; if(pins[idx]) setPinnedColor(idx); else clearPinnedColor(idx); }
      }
      e.preventDefault();
    }
    function onMouseUp(){ grabbing=-1; }
    function onContextMenu(e){ e.preventDefault(); }
    function onKey(e){ if(e.code==='Space'){ running = !running; btnPause.textContent= running? 'Pause':'Play'; btnPause.classList.toggle('primary', running); if(running){ lastTS=performance.now(); requestAnimationFrame(tick);} } }

    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    renderer.domElement.addEventListener('contextmenu', onContextMenu);
    window.addEventListener('keydown', onKey);

    // ======================== Controls & API ========================
    function applyUI(){
      timeScale = +rngTime.value; damping = +rngDamp.value; mouseK = +rngMouseK.value; kCouple = +rngKc.value;
      var r = +rngR.value; rCouple = r; r2 = r*r; cellSize = Math.max(0.8, 0.9*rCouple);
      k1=+rngK1.value; k2=+rngK2.value; k3=+rngK3.value; k4=+rngK4.value;
      updatePointSize(+rngPSize.value);
      gridHelper.visible = chkGrid.checked; axesHelper.visible = chkAxes.checked;
      syncLabels();
    }
    btnPause.addEventListener('click', function(){ running=!running; btnPause.textContent= running? 'Pause':'Play'; btnPause.classList.toggle('primary', running); if(running){ lastTS=performance.now(); requestAnimationFrame(tick);} });
    btnReset.addEventListener('click', function(){ resetSim(); });
    btnPulse.addEventListener('click', function(){ pulse(); });
    btnRand.addEventListener('click', function(){ randomImpulse((Math.random()*1e9)|0); });
    rngTime.addEventListener('input', applyUI);
    rngDamp.addEventListener('input', applyUI);
    rngMouseK.addEventListener('input', applyUI);
    rngPSize.addEventListener('input', applyUI);
    rngK1.addEventListener('input', applyUI);
    rngK2.addEventListener('input', applyUI);
    rngK3.addEventListener('input', applyUI);
    rngK4.addEventListener('input', applyUI);
    rngKc.addEventListener('input', applyUI);
    rngR.addEventListener('input', applyUI);
    chkGrid.addEventListener('change', applyUI);
    chkAxes.addEventListener('change', applyUI);

    function resetSim(){
      for(var i=0;i<N;i++){
        px[i]=restX[i]; py[i]=restY[i]; pz[i]=restZ[i];
        vx[i]=vy[i]=vz[i]=0; fx[i]=fy[i]=fz[i]=0; pins[i]=0;
      }
      // restore colors
      for(var c=0;c<numClouds;c++){
        var r = renders[c]; var col = new THREE.Color(clouds[c].color); var R=col.r,G=col.g,B=col.b; var j;
        for(j=0;j<r.count;j++){ var base=j*3; r.colors[base]=R; r.colors[base+1]=G; r.colors[base+2]=B; }
        r.attrCol.needsUpdate = true;
      }
    }

    function pulse(){
      // Radial outward velocity based on position vector
      var i, dx,dy,dz, invL;
      for(i=0;i<N;i++){
        dx = px[i]; dy = py[i]; dz = pz[i];
        var L = Math.sqrt(dx*dx+dy*dy+dz*dz) + 1e-6; invL = 1.0/L;
        vx[i] += dx*invL*1.5; vy[i] += dy*invL*1.5; vz[i] += dz*invL*1.5;
      }
    }

    function randomImpulse(seed){ if(seed!==undefined) seedRandom(seed); for(var i=0;i<N;i++){ vx[i] += (rand()-0.5)*2.5; vy[i] += (rand()-0.5)*2.5; vz[i] += (rand()-0.5)*2.5; } }

    function setCoupling(k,r){ rngKc.value = String(k); rngR.value = String(r); applyUI(); }
    function setStiffness(a,b,c,d){ rngK1.value=String(a); rngK2.value=String(b); rngK3.value=String(c); rngK4.value=String(d); applyUI(); }
    function pause(flag){ running = (flag===undefined)? !running : !(!flag); btnPause.textContent= running? 'Pause':'Play'; btnPause.classList.toggle('primary', running); if(running){ lastTS=performance.now(); requestAnimationFrame(tick);} }

    window.api = { setCoupling:setCoupling, setStiffness:setStiffness, pulse:pulse, randomImpulse:randomImpulse, pause:pause, reset:resetSim, seedRandom:seedRandom };

    // ======================== Main loop ========================
    function zeroForces(){
      for(var i=0;i<N;i++){ fx[i]=0; fy[i]=0; fz[i]=0; }
    }

    function tick(ts){
      var t0 = performance.now();
      var rawDt = (ts - lastTS)/1000; if(rawDt<0) rawDt=0; if(rawDt>0.1) rawDt=0.1; // cap grotesque pauses
      lastTS = ts;
      var dt = Math.min(1/20, rawDt) * timeScale;
      var steps = (rawDt>1/30)? 2:1; var subDt = dt/steps;
      for(var s=0;s<steps;s++){
        zeroForces();
        rebuildHash();
        applyInternal();
        applyCoupling();
        applyMouseSpring();
        integrate(subDt);
      }
      var t1 = performance.now();
      updateGeometries();
      controls.update();
      renderer.render(scene, camera);
      var t2 = performance.now();
      // Diagnostics EMA
      simMS = simMS*(1-ema) + (t1-t0)*ema;
      rendMS = rendMS*(1-ema) + (t2-t1)*ema;
      hud.textContent = 'ms: sim '+simMS.toFixed(2)+' | rend '+rendMS.toFixed(2)+' | pairs '+pairCount+' | cell '+cellSize.toFixed(2)+' | N '+N;
      if(running) requestAnimationFrame(tick);
    }

    // ======================== Resize & bootstrap ========================
    function onResize(){
      renderer.setSize(stage.clientWidth, stage.clientHeight);
      camera.aspect = stage.clientWidth/stage.clientHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize, {passive:true});

  initArrays();
  applyUI();
  onResize();
  // Push initial positions to GPU before first render
  updateGeometries();
    requestAnimationFrame(tick);

    // Startup banner
    console.log('[Interfering Dots] N=%d, buckets=%d, cellSize=%.2f, damping=%.3f, k_cpl=%d, r=%.2f', N, BUCKETS, cellSize, damping, kCouple|0, Math.sqrt(r2));
  })();
  </script>
</body>
</html>
